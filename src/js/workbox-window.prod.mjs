try{self["workbox:window:6.0.0"]&&_()}catch(t){}function t(t,s){return new Promise((i=>{const e=new MessageChannel;e.port1.onmessage=t=>{i(t.data)},t.postMessage(s,[e.port2])}))}try{self["workbox:core:6.0.0"]&&_()}catch(t){}class s{constructor(){this.promise=new Promise(((t,s)=>{this.resolve=t,this.reject=s}))}}function i(t,s){const{href:i}=location;return new URL(t,i).href===new URL(s,i).href}class e{constructor(t,s){this.type=t,Object.assign(this,s)}}const h={type:"SKIP_WAITING"};class n extends class{constructor(){this.t=new Map}addEventListener(t,s){this.i(t).add(s)}removeEventListener(t,s){this.i(t).delete(s)}dispatchEvent(t){t.target=this;const s=this.i(t.type);for(const i of s)i(t)}i(t){return this.t.has(t)||this.t.set(t,new Set),this.t.get(t)}}{constructor(t,h={}){super(),this.h={},this.o=0,this.g=new s,this.l=new s,this.u=new s,this.m=0,this.v=new Set,this.p=()=>{const t=this.S,s=t.installing;this.o>0||!i(s.scriptURL,this.P)||performance.now()>this.m+6e4?(this.W=s,t.removeEventListener("updatefound",this.p)):(this._=s,this.v.add(s),this.g.resolve(s)),++this.o,s.addEventListener("statechange",this.L)},this.L=t=>{const s=this.S,i=t.target,{state:h}=i,n=i===this.W,a={sw:i,isExternal:n,originalEvent:t};!n&&this.I&&(a.isUpdate=!0),this.dispatchEvent(new e(h,a)),"installed"===h?this.B=self.setTimeout((()=>{"installed"===h&&s.waiting===i&&this.dispatchEvent(new e("waiting",a))}),200):"activating"===h&&(clearTimeout(this.B),n||this.l.resolve(i))},this.C=t=>{const s=this._;s===navigator.serviceWorker.controller&&(this.dispatchEvent(new e("controlling",{sw:s,originalEvent:t,isUpdate:this.I})),this.u.resolve(s))},this.R=async t=>{const{data:s,source:i}=t;await this.getSW(),this.v.has(i)&&this.dispatchEvent(new e("message",{data:s,sw:i,originalEvent:t}))},this.P=t,this.h=h,navigator.serviceWorker.addEventListener("message",this.R)}async register({immediate:t=!1}={}){t||"complete"===document.readyState||await new Promise((t=>window.addEventListener("load",t))),this.I=Boolean(navigator.serviceWorker.controller),this.T=this.U(),this.S=await this.M(),this.T&&(this._=this.T,this.l.resolve(this.T),this.u.resolve(this.T),this.T.addEventListener("statechange",this.L,{once:!0}));const s=this.S.waiting;return s&&i(s.scriptURL,this.P)&&(this._=s,Promise.resolve().then((()=>{this.dispatchEvent(new e("waiting",{sw:s,wasWaitingBeforeRegister:!0}))})).then((()=>{}))),this._&&(this.g.resolve(this._),this.v.add(this._)),this.S.addEventListener("updatefound",this.p),navigator.serviceWorker.addEventListener("controllerchange",this.C,{once:!0}),this.S}async update(){this.S&&await this.S.update()}get active(){return this.l.promise}get controlling(){return this.u.promise}getSW(){return void 0!==this._?Promise.resolve(this._):this.g.promise}async messageSW(s){return t(await this.getSW(),s)}messageSkipWaiting(){this.S&&this.S.waiting&&t(this.S.waiting,h)}U(){const t=navigator.serviceWorker.controller;return t&&i(t.scriptURL,this.P)?t:void 0}async M(){try{const t=await navigator.serviceWorker.register(this.P,this.h);return this.m=performance.now(),t}catch(t){throw t}}}export{n as Workbox,t as messageSW};
//# sourceMappingURL=workbox-window.prod.mjs.map